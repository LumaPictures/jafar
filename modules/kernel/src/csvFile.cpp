/* $Id$ */
#include "kernel/csvFile.hpp"

using namespace jafar::kernel;

/*
 * class CSVFileReader
 */

CSVFile::CSVFile(std::string const& separator_, char commentPrefix_, bool withColumnsNames_) :
  m_separator(separator_),
  m_commentPrefix(commentPrefix_),
  withColumnsNames(withColumnsNames_),
	lineNumber(0), dataLineNumber(0), columnNumber(0)
{}

void CSVFile::hasColumnsNames(const bool&  _withColumnsNames) {
  withColumnsNames = _withColumnsNames;
}

bool CSVFile::hasColumn(const std::string& _columnName) const {
  std::map<std::string, int>::const_iterator it = columnNames.find(_columnName);
  return it != columnNames.end();
}

size_t CSVFile::nbOfLines() const {
//   return fileMatrix.size1();
  return dataLineNumber;
}

size_t CSVFile::nbOfColumns() const {
  return fileMatrix.size2();
}

void CSVFile::compute_matrix_size(const std::string& _filename, 
																	size_t& nb_lines,
																	size_t& nb_columns,
																	const std::string& _separator,
																	char _commentPrefix){
	std::ifstream _file(_filename.c_str());
  JFR_IO_STREAM(_file, "CSVFile::readFile: failed to open file: " << _filename);
	nb_lines = 0;
	nb_columns = 0;
	bool are_columns_computed = false;
	std::string line;
	while(!_file.eof()) {
		getline(_file, line);
		if(line.size() == 0 || line.at(0) == _commentPrefix || ( line.size() == 1 && line.at(0) == 13 ))
			continue;
		else if (!are_columns_computed){
			const boost::char_separator<char> _sep(_separator.c_str());
			typedef boost::tokenizer<boost::char_separator<char> > tokenizer;
			tokenizer tokens(line, _sep);
			tokenizer::iterator it = tokens.begin();
			assert(it != tokens.end());
			for(it = tokens.begin(); it != tokens.end(); it++)
				nb_columns++;
			are_columns_computed = true;
		}
		nb_lines++;
	}
	_file.close();
}

void CSVFile::readFile(std::string const& filename) {
  using namespace std;
  //cout<<">>> csvFile_read"<<endl;
  ifstream file(filename.c_str());
  JFR_IO_STREAM(file, "CSVFile::readFile: failed to open file: " << filename);
	size_t nb_of_lines, nb_of_columns;
	//check the first line to compute number of columns
  string line;
  // tokenizer
  typedef boost::tokenizer<boost::char_separator<char> > tokenizer;
  boost::char_separator<char> sep(m_separator.c_str());
  compute_matrix_size(filename, nb_of_lines, nb_of_columns, m_separator, m_commentPrefix);
	fileMatrix.resize(nb_of_lines, nb_of_columns);
  // reading the lines
  while(getline(file,line)) {
    // this is an empty line or a comment
    if (line.size() == 0 || line.at(0) == m_commentPrefix || ( line.size() == 1 && line.at(0) == 13 ))
      continue;
    tokenizer tokens(line, sep);
    tokenizer::iterator it = tokens.begin();
    JFR_PRED_ERROR(it != tokens.end(),
                   KernelException,
                   KernelException::CSVFILE_INVALID_LINE,
                   "CSVFile::readFile: invalid line at " << filename << ":" << lineNumber);
    //treat the title line
    if(withColumnsNames && lineNumber == 1){
      //      cout <<"with titles"<<endl;
      for(it = tokens.begin(), columnNumber = 0; 
          it != tokens.end(); 
          ++it, ++columnNumber) {
        columnNames[*it] = columnNumber;
      }
      //generate column names if no title line and treat data
    } else if (!withColumnsNames && lineNumber == 1) {
      //cout <<"without titles"<<endl;
      std::stringstream ss;
      ++dataLineNumber;
      for(it = tokens.begin(), columnNumber = 0; 
          it != tokens.end(); 
          ++it, ++columnNumber) {
        ss << "column_" << columnNumber;
        columnNames[ss.str()] = columnNumber;
        ss << std::flush;
        fileMatrix(0, columnNumber) = *it;
			}
      //treat data line
		} else {
      ++dataLineNumber;
      for(it = tokens.begin(), columnNumber = 0; 
          it != tokens.end(); 
          ++columnNumber, ++it) {
        fileMatrix(dataLineNumber-1, columnNumber) = *it;
			}
		}
		//    cout << "data line nÂ° "<<dataLineNumber<<endl;
  }//while loop
  file.close();
  //cout<<"<<< csvFile_read"<<endl;
}

void CSVFile::writeFile(std::string const& filename) {
  std::ofstream file(filename.c_str());
  JFR_IO_STREAM(file, "CSVFile::writeFile: failed to open file: " << filename);

  file << m_commentPrefix <<" Generated by CSVFile::writeFile" << std::endl;
  file << m_commentPrefix <<" ";
  file << boost::posix_time::to_simple_string(boost::posix_time::second_clock::local_time());
  file << std::endl;
  file << std::endl;
  for (size_t line = 0; line < fileMatrix.size1(); ++line) {
    for (size_t col = 0; col < (fileMatrix.size2()-1); ++col) {
      file << fileMatrix(line, col) << m_separator;
    }
    //writes the last column of line and inserts a break
    file << fileMatrix(line, (fileMatrix.size2()-1)) << "\n";
  }
  file.close();
}

/*
 * class CSVFileLoad
 */
void CSVFileLoad::load(std::string const& filename,
                       std::string const& separator_, 
                       char commentPrefix_) {
  JFR_TRACE_BEGIN;
  CSVFile csvf(separator_, commentPrefix_);
  csvf.readFile(filename);
  loadCSVFile(csvf);
  JFR_TRACE_END("CSVFile::load: loaded file " << filename);
}

/*
 * class CSVFileSave
 */
void CSVFileSave::save(std::string const& filename,
                       std::string const& separator_, 
                       char commentPrefix_) {
  JFR_TRACE_BEGIN;
  CSVFile csvf(separator_, commentPrefix_);
  saveCSVFile(csvf);
  csvf.writeFile(filename);
  JFR_TRACE_END("CSVFile::save: saved file " << filename);
}

