/* $Id$ */

#include <fstream>

#include "boost/date_time/posix_time/posix_time.hpp"
#include "boost/tokenizer.hpp"

#include "kernel/csvFile.hpp"

using namespace jafar::kernel;

/*
 * class CSVFileReader
 */

CSVFile::CSVFile(std::string const& separator_, char commentPrefix_, bool withColumnsNames_) :
  m_separator(separator_),
  m_commentPrefix(commentPrefix_),
  withColumnsNames(withColumnsNames_)
{
  lineNumber = 0;
  dataLineNumber = 0;
  columnNumber = 0;
}

void CSVFile::hasColumnsNames(const bool&  _withColumnsNames) {
  withColumnsNames = _withColumnsNames;
}

bool CSVFile::hasColumn(const std::string& _columnName) const {
  std::map<std::string, int>::const_iterator it = columnNames.find(_columnName);
  return it != columnNames.end();
}

size_t CSVFile::nbOfLines() const {
//   return fileMatrix.size1();
  return dataLineNumber;
}

size_t CSVFile::nbOfColumns() const {
  return fileMatrix.size2();
}

void CSVFile::readFile(std::string const& filename) {
  using namespace std;
  //cout<<">>> csvFile_read"<<endl;
  ifstream file(filename.c_str());
  JFR_IO_STREAM(file, "CSVFile::readFile: failed to open file: " << filename);

  string line;
  // tokenizer
  typedef boost::tokenizer<boost::char_separator<char> > tokenizer;
  boost::char_separator<char> sep(m_separator.c_str());
  size_t maxNbTokens = 0;
  // reading the lines
  while(getline(file,line)) {
    // this is an empty line or a comment
    if (line.size() == 0 || line.at(0) == m_commentPrefix || ( line.size() == 1 && line.at(0) == 13 ))
      continue;
    ++lineNumber;
    tokenizer tokens(line, sep);
    tokenizer::iterator it = tokens.begin();
    JFR_PRED_ERROR(it != tokens.end(),
                   KernelException,
                   KernelException::CSVFILE_INVALID_LINE,
                   "CSVFile::readFile: invalid line at " << filename << ":" << lineNumber);
    //treat the title line
    if(withColumnsNames && lineNumber == 1){
      //      cout <<"with titles"<<endl;
      for(it = tokens.begin(), columnNumber = 0; 
          it != tokens.end(); 
          ++it, ++columnNumber) {
        columnNames[*it] = columnNumber;
      }
      //generate column names if no title line and treat data
    } else if (!withColumnsNames && lineNumber == 1) {
      //cout <<"without titles"<<endl;
      std::stringstream ss;
      ++dataLineNumber;
      for(it = tokens.begin(), columnNumber = 0; 
          it != tokens.end(); 
          ++it, ++columnNumber) {
        ss << columnNumber;
        columnNames[ss.str()] = columnNumber;
        ss << std::flush;
        if (columnNumber > maxNbTokens){
          maxNbTokens = columnNumber;
        }
        fileMatrix.resize(1, maxNbTokens+1);
        fileMatrix(0, columnNumber) = *it;
      }
      //treat data line
    } else {
      ++dataLineNumber;
      for(it = tokens.begin(), columnNumber = 0; 
          it != tokens.end(); 
          ++columnNumber, ++it) {
        if (columnNumber > maxNbTokens){
          maxNbTokens = columnNumber;
        }
        fileMatrix.resize(dataLineNumber, maxNbTokens+1);
        fileMatrix(dataLineNumber-1, columnNumber) = *it;
      }
    }
    //cout << "data line nÂ° "<<dataLineNumber<<endl;
  }//while loop
  file.close();
  //cout<<"<<< csvFile_read"<<endl;
}

void CSVFile::writeFile(std::string const& filename) {
  std::ofstream file(filename.c_str());
  JFR_IO_STREAM(file, "CSVFile::writeFile: failed to open file: " << filename);

  file << m_commentPrefix <<" Generated by CSVFile::writeFile" << std::endl;
  file << m_commentPrefix <<" ";
  file << boost::posix_time::to_simple_string(boost::posix_time::second_clock::local_time());
  file << std::endl;
  file << std::endl;
  for (size_t line = 0; line < fileMatrix.size1(); ++line) {
    for (size_t col = 0; col < (fileMatrix.size2()-1); ++col) {
      file << fileMatrix(line, col) << m_separator;
    }
    //writes the last column of line and inserts a break
    file << fileMatrix(line, (fileMatrix.size2()-1)) << "\n";
  }
  file.close();
}

/*
 * class CSVFileLoad
 */
void CSVFileLoad::load(std::string const& filename,
                       std::string const& separator_, 
                       char commentPrefix_) {
  JFR_TRACE_BEGIN;
  CSVFile csvf(separator_, commentPrefix_);
  csvf.readFile(filename);
  loadCSVFile(csvf);
  JFR_TRACE_END("CSVFile::load: loaded file " << filename);
}

/*
 * class CSVFileSave
 */
void CSVFileSave::save(std::string const& filename,
                       std::string const& separator_, 
                       char commentPrefix_) {
  JFR_TRACE_BEGIN;
  CSVFile csvf(separator_, commentPrefix_);
  saveCSVFile(csvf);
  csvf.writeFile(filename);
  JFR_TRACE_END("CSVFile::save: saved file " << filename);
}

