/* $Id$ */

/*!
  \addtogroup slam Module slam

\version 2.0

\author 
  thomas.lemaire@laas.fr

  SLAM (Simultaneous Localization And Mapping) is a fundamental
problem for robotics.

  The module slam implements several algorithms: 

  - The classic SLAM algorithm based on a extended kalman filter 
  - An original algorithm for the special bearing-only SLAM problem, a
  multi gaussian distribution is used to approximate the initial
  state. This is a delayed initialization algorithm.
  - The inverse-depth monocular SLAM algorithms. This is an undelayed initialization algorithm
  - A delayed monocular SLAM with segments.
  - An undelayed monocular SLAM with segments.

  Currently, sizeless points, iinverse-depth points and Plucker lines can be used as features.

\section secSlamHistory  History

  - 0.7 (2007-03-07) - port to datareader
  - 0.6 (2006-07-10) -
  - 0.5 (2006-05-29) - smart selection of robot poses in boSLAM, points at inifinity are now considered, implementation of "inverse-depth" parametrization for boSLAM
  - 0.4 (2006-04-18) - boSLAM using an omni camera
  - 0.3 (2005-12-15) - boSLAM with segments
  - 0.2 (2004-12-15) - Bearing-only SLAM 
  - 0.1 (2004-10-18) - Initial version, basic slam based on an EKF,
point features

\section secSlamOverview Overview

\subsection subsecSlamOverviewClass Main classes

  - jafar::slam::SlamEkf implements the classic EKF based SLAM algorithm
  - jafar::slam::BearingOnlySlam implements the bearings-only SLAM
algorithm described in my thesis (Thomas Lemaire thesis)
  - jafar::slam::BaseFeature is the feature container
  - jafar::slam::FeatureModel defines how to compute a landmark state vector in a different frame
  - jafar::slam::FeatureObserveModel defines an observation model for a given sensor and type of landmark
  - jafar::slam::BearingOnlyFeatureObserveModel defines an observation model for a given bearings sensor and type of landmark

\subsection subsecSlamOverviewExample Example of use (in tcl)

\verbatim

#
# setup
#

# create a Slam object
set slamEkf [slam::new_SlamEkf 350 6 6]

# optionnaly change the map manager
#   $slamEkf setMapManager [slam::new_LocalMapManager $slamEkf 40 3]
#   $slamEkf setMapManager [slam::new_GlobalMapManager $slamEkf 3 3.0]

# covariance update method (DEFAULT, STANDARD, JOSEPH)
[$slamEkf getFilter] setCovUpdateType $filter::BaseKalmanFilter_STANDARD
# consistency check method
[$slamEkf getFilter] setupConsistencyCheck $::filter::BaseKalmanFilter_CONSISTENCY_EXCEPTION 10.0


# create a landmark model
set ptModel [slam::new_PointFeatureModel]
# create an associated observe model
set ptObsModel [slam::new_PolarPointFeatureObserveModel $ptModel]
$ptObsModel setNoiseValues 0.1 [jmath::degToRad 2] [jmath::degToRad 2]
# add the defined sensor to Slam
$slamEkf setSensor $ptObsModel
# set the robot to sensor t3d
set robotToSensor [jmath::new_vec 6]
jmath::setValue $robotToSensor "(0,0,1.0,[jmath::degToRad 90],0,0)"
$slamEkf setRobotToSensor $robotToSensor

# create a prediction model
set odoPredictModel [slam::new_Odo3dPredictModel]
[$odoPredictModel cget -odoNoiseModel] set [expr pow(0.05,2)] 0 [expr pow(0.05,2)] 0

#
# run
#

# predict with command u [v,w]
$slamEkf predict $predictModel $u

# update
FIXME

\endverbatim


\subsection subsecSlamOverviewExample Example of use (in ruby)

\verbatim

# create and initialize the slam object
slamEkf = Slam::SlamEkf.new(350, 6, 6)
slamEkf.getFilter.setCovUpdateType(Filter::BaseKalmanFilter::STANDARD)
slamEkf.getFilter.setupConsistencyCheck(Filter::BaseKalmanFilter::CONSISTENCY_EXCEPTION, 10.0)

# create a landmark model
ptModel = Slam::PointFeatureModel.new
# create an associated observe model
ptObsModel = Slam::PolarPointFeatureObserveModel.new( ptModel )
ptObsModel.setNoiseValues( 0.1, Jmath::degToRad(2), Jmath::degToRad(2))
# add the defined sensor to Slam
slamEkf.setSensor(ptObsModel)
# set the robot to sensor t3d
robotToSensor = Jmath::Vec.new(6)
Jmath::setValue(robotToSensor, "(0,0,1.0,#{Jmath::degToRad(90)},0,0)")
slamEkf.setRobotToSensor(robotToSensor)

# create a prediction model
odoPredictModel = Slam::Odo3dPredictModel.new
odoPredictModel.odoNoiseModel.set(Math::exp( 0.05 ** 2 ), 0, Math::exp( 0.05 ** 2 ), 0 )

#
# run
#

# predict with command u [v,w]
u = Jmath::Vec.new(2)
slamEkf.predict(odoPredictModel, u)

# update
#       FIXME
\endverbatim


\section secSlamMacro Macro

  Extra doc for macro can go here... (you can delete this section if
not relevant)

\section secSlamInterface Tcl interface (generated by swig)

  The interface of the module is generated from the following files:
    - slam.i defines the wrapped classes and functions,
    - slamException.i defines the \c try { } \c catch block
for this module.

*/

