/* $Id$ */
 
/** \page pageJafarModule Jafar module

\section secModuleOverview Overview

Jafar is a modular framework which is intended to gather algorithms
developped by various people. A module contains classes and functions
related to the same algorithm, or group of algorithms. A jafar module
is constituted by:

    - source code and headers,
    - configure scripts and and a makefile,
    - errors definition (\ref pageJafarError),
    - swig wrapped interface definition (\ref secModuleSwig),
    - documentation (\ref secModuleDocumentation).

A jafar module provides:
    - static and shared library,
    - tcl package,
    - html documentation generated by doxygen.

\section secModuleNewModule New module

A new module can easily be created with the jafar-module
tool. jafar-module is a tcl script in the \c $JAFAR_DIR/bin
directory. To create a new module with name toto:

\verbatim
$ $JAFAR_DIR/bin/jafar-module -c toto
\endverbatim

A new directory \c toto will be created in \c $JAFAR_DIR/modules wich
contains a minimal set of files with a already usable \c Makefile to
compile the module (refer to \ref subsecFrameworkMakefile) (if you have already invoked the configure
script at the root of your jafar).

\subsection subsecModuleName The name of the module.

Choosing the name of a module is an important step :-). You will try
to find the perfect name, short enough, precise enough, for your
module to become famous (do not forget the cool algo in it !). The
name of a module must be unique, at least within the set of modules
you may use. Note that the name should contain only lower-case
caracters (this is currently a Swig limitation). This name defines
several other names:

    - of the subdirectories in \c $JAFAR_DIR/modules/, in \c $JAFAR_DIR/include/, in \c $JAFAR_DIR/tclpkg/$TARGET/
    - of the c++ namespace in which your module will live, something like \c jafar::module,
    - of the root exception class of all the exceptions of your module, \c ModuleException,
    - of the tcl package you will load with package require module,
    - of the tcl namespace in which all the classes and functions wrapped will lie in, \c module::,
    - of the doxygen group in which one can access all the documentation of your module.

To go further with your new module please read \ref pageCodeDocRules

\section secModuleFilesLayout Files layout

\image html moduleLayout.png "Module files layout (module helloworld)"

\section secModuleUserMake User.make file

\subsection subsecModuleUserMakeStandard Customize the compilation process: standard flags

\c User.make is the file where developpers can configure the compilation process for their module.

Standard compilation flags can be modified (\c CPPFLAGS, \c CXXFLAGS, \c LDFLAGS, \c LIBS) so that the compiler finds all the necessary external libraries. Please make use of the variables defined by the configure process (see \ref secInstallConfigureMake).

\subsection subsecModuleUserMakeJafar Customize the compilation process: Jafar specific flags
Compilation process of Jafar is driven by a few flags:
  - \c JFR_NDEBUG: when this flag is defined, the specific debug checks, messages and trace mechanism are disabled. The following macros are desactivated: \ref JFR_PRECOND, \ref JFR_POSTCOND, \ref JFR_INVARIANT, \ref JFR_DEBUG, \ref JFR_VDEBUG, \ref JFR_VVDEBUG, \ref JFR_TRACE, \ref JFR_TRACE_BEGIN, \ref JFR_TRACE_POINT, \ref JFR_TRACE_END. \ref JFR_WARNING sends its messages to std::cerr.
  - \c JFR_QUIET disable also warning messages (when JFR_NDEBUG is defined).

\subsection subsecModuleDependencies Inter modules dependancies

You are developping module \e pipo, and your module depends on module \e image, then you need to modify \c User.make in \e pipo:

- Add \e image to the list of modules in \c USE_MODULES. During the compilation process, these modules will be checked for beeing up to date.
- Add the \c -l option to the \c LIBS variable if needed (no need to modify other flags).

\verbatim
USE_MODULES = kernel image
LIBS += -lkernel -limage
\endverbatim

\section secModuleVersion Module versions policy

The version of a module is defined in \c User.make by two variables,
MODULE_VERSION and MODULE_REVISION. MODULE_REVISION should increment
when small improvments are done which do not break the
API. MODULE_VERSION should increment when huge modifications are done,
MODULE_REVISION is then reset to 0. 

\section secModuleSwig Swig .i files

The shared library part of the tcl package of the module is generated
using the Simple Wrapping Interface Generator. SWIG parses \c .i files
in the \c include/ directory to know the classes and functions to be
wrapped. This is up to the developper to add the needed directives in
the \c module.i skeleton file that comes with the module. For more
information please refer to the swig documentation (http://www.swig.org/Doc1.3/Sections.html).

At minimum, the developper will add some \c #include inside the \%{
and \%} section and \c \%include. Swig will generate a file \c
module_wrap.cpp in the \c src/tcl/ directory, do not edit this file as
it is regenerated each time Swig is called.

\%{ and \%} section contains headers necessary to compile \c
module_wrap.cpp, generally it constains the headers wrapped and also
headers defining data types which appears in the wrapped classes or
functions.

The \c \%include specify headers containing classes and functions to
be wrapped. These functions will be made available in a tcl shell
throught the generated package. Note that the \c \%include directive
is not recursive by default. All data types that are needed, but are
not wrapped (which are defined in a #included but not \%included file)
will be manipulated as pointers in tcl.

Also Swig comes with a library of \c .i files that enables to wrap
standard data types such as \c std::string. This library is getting more
powerfull and complete with new releases of Swig. A first example
comes with the helloworld module:

\include helloworld.i

For information about \c moduleException.i, please refer to \ref
secExceptionSwigTcl. In the general case you will not have to modify
this file.

\subsection subsecModuleSwigTools moduleSwig.hpp

This file initially contains a template \c print functions which may
be instantiated with different types (in the .i file using
\%template). This file is intended to contain such helper functions to
be used in the interactive shell (tclsh,...).

\section secModuleMacro Tcl macros

You can add in the \c macro/ directory standard tcl procedures you
want to include in the tcl package, they will be available after a
\c package \c require \c module. You must follow a few rules:

  - your tcl procedures must be declared in the module namespace,
  - for each tcl script you must add a \c package \c provide command
using the \e same version number as in \c User.make

Do not forget to follow \ref pageCodeDocRules. Here is an example from helloworld module:

\include demoHello.tcl

\section secModuleDocumentation Module documentation

In addition to the source documentation in the header files, one
should add at least a short description of the module in the
doc/module.doxy file.

The \c doc/doxygen/module.doxy file already contains a skeleton. Write
general doc in this file and organize it as you wish, make use of
sectionning commands and others to structure your document and add
hyperlinks. Be aware that label names in doxygen are global, it is better
to prefix them with the module name for example.

*/
